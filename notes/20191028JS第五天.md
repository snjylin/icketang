## 复习：
#### 流程语句
    1) 条件if语句
        格式一：条件满足执行花括号中的语句，不满足不执行任何操作
            if(条件表达式){
                条件语句
            }
        格式二：不管条件是否满足，都会有一条对应的语句体
            if(条件表达式){
                条件表达式成立执行的语句
            }else{
                条件表达式不成立执行的语句
            }
        格式三：多重条件判断
            if(条件表达式一){
                条件表达式一成立执行的语句体
            }else if(条件表达式二){
                条件表达式二成立执行的语句体
            }...else if(条件表达式N){
                条件表达式N成立执行的语句体
            }else{
                以上条件都不成立执行的语句体
            }
    2) 选择switch语句
        switch(条件表达式){
            case 值1:
                匹配到值1执行的语句体;
                break;
            case 值2:
                匹配到值2执行的语句体;
                break;
                .......
            case 值N:
                匹配到值N执行的语句体;
                break;
            default:
                以上case值都没有匹配到执行的语句;
                break;
        }

    3) 循环语句
        while循环
            while(循环条件){
                循环体
            }

        do...while循环
            do{
                循环体
            }while(循环条件)

        for循环
            for(初始化变量; 循环条件;变量的操作){
                循环体
            }

    执行步骤:
        1. 初始化变量
        2. 判断循环条件是否满足
        3. 循环条件满足，执行循环体
        4. 变量操作
        5. 重复执行2，3，4步，直到循环条件不满足跳出循环

    举例：
    ```
    for(var i = 1; i <= 10; i += 3){
        console.log(“i:”,i);//1  4  7  10
    }
    console.log(“i:”,i);//13
    ```

    控制语句
        continue  继续的意思；跳过本次循环继续下一次循环
        break  打断的意思；跳出当前循环

        在嵌套循环下，如果想跳出或跳过指定循环，那么需要在指定循环外做标记。

## 函数
将重复功能进行封装，减少重复代码书写，优化程序。
#### 函数的声明：
    使用关键字function
    普通的方式声明函数：
        function 函数名(参数列表){
            函数体
        }
    变量的方式声明函数：
        var 函数名 =  function(参数列表){函数体}
        赋值运算符”=”后面是一个函数表达式，也是一个匿名函数，匿名函数又叫做拉姆达函数。
#### 函数的命名：同变量命名方式（构造函数除外大驼峰命名）

#### 函数的调用
    函数被声明后，不会自动执行，需要在脚本中进行调用，调用方式如下：
        事件驱动；
        在脚本的任何位置直接写函数名()

#### 函数的作用域
    局部作用域
        在传统的js中，可以把声明函数后，大括号中函数体区域看做是局部作用域；在局部作用域内声明的变量叫做局部变量；局部变量只能在当前函数内调用，函数外无法调用；局部变量在函数调用时生成，函数调用完毕后销毁。
    全局作用域
        函数外部整个js脚本区域都可以看做是全局作用域；在全局作用域内声明的变量，叫做全局变量；全局变量可以在整个js脚本任何位置都可以调用；全局变量，在程序执行时（页面打开时）生成，程序(页面)关闭后销毁。
    ```
    var i = 1;
    f();
    function f(){
        console.log("i:",i);    // i:undefined
        var i = 2;
        console.log("i:",i);    // i: 2
        // 链式作用域改变：嵌套函数中，或不同作用域下，局部作用域中变量调用时，会先在当前作用域中寻找是否有这个变量的声明，如果没有再一层一层往上查找直到找到这个变量为止
    }
    console.log("i:",i);    // i: 1
    ```

#### 函数的提升
    在js中，程序的执行分成两步：预解析和运行阶段；
    预解析阶段，会将当前作用域内所有变量的声明和普通函数整体提升到作用域最顶部，运行阶段进行赋值操作。同一个作用域，存在同名变量和函数，函数的声明优先；其它再次声明为赋值操作（同名变量或函数只会被声明一次）。

#### 函数的参数：
    形式参数：在声明函数函数时，写在函数名后面括号中的局部变量（但不需要使用var声明），简称形参；此时并不能确定具体的值和数据类型。
    实际参数：在函数调用时，传入到函数名后括号中用来替换形参的具体值，简称实参；此时可以确定具体的值和数据类型。

#### 函数的重载和重写
    重载：在同一个程序中，声明多个函数名相同，参数列表的数量或数据类型不同的函数叫做函数的重载；
    重写：存在继承关系的程序中，子类去重新定义父类中的方法（函数），叫做重写；

    JS是一个动态的、弱类型语言。
    JS中不存在重载的概念，但是我们可以使用arguments对象模拟；
    如果在JS中声明了多个同名函数，后面的函数覆盖前面的函数。
#### arguments对象
    arguments 是一个对应于传递给函数的参数的类数组对象。
    JS中一个特殊的对象，代表的是所有的参数；它是一个参数列表，是一个类数组；
    类数组和数组一样，有长度，有索引；
    长度通过length属性获取，得到的是参数的个数；
    索引，也叫下标，都是从0开始，一次递增的
    可以通过索引获取对应索引的参数 arguments[0] 获取第一个参数  arguments[argument.length - 1]获取最后一个参数

#### 函数的返回值
    更多的时候，我们不会在函数中直接输出数据；会使用return关键字返回一个值，便于二次使用；
    return除了在函数调用时，可以返回指定的值；还可以用来跳出函数用。

    面试题：return 、break 、 continue区别
        return 调用函数时用来返回值或跳出函数用
        break用来跳出指定循环或者switch语句
        continue跳过本次循环继续下一次循环

## 匿名函数和立即执行函数（自执行函数）
    匿名函数：顾名思义，就是没有名字的函数
    立即执行函数（IIFE）:又称自执行函数，一般在程序运行时只执行一遍的操作，一般会使用自执行函数操作

    自执行函数由两个小括号包裹，第一个小括号包裹的是函数体，第二个小括号用来执行函数（第一个小括号也可以用别的符号代替，如~ ! + -）
    自执行函数前面的代码必须以分号结束，为了避免前面代码没用分号结束的情况，一般会在自执行函数前加个分号
    ```
    ;(function(a,b){
        console.log(a+b);
    })(10,20);
    ;~function(a,b){
        console.log(a+b);
    }(10,20);
    ```
    自执行函数可以避免全局变量的污染

## 递归函数
    一个函数在函数体内调用函数自己，叫做递归函数；
    递归函数一般用来解决数学问题。解决的都是大于0的数据操作；
    递归函数必须给定一个条件来跳出，否则会造成内存堆栈溢出( Maximum call stack size exceeded)。

    可以解决问题如：
        累加
            1 + 2 + 3 + ... + 97 + 98 + 99 + 100
        阶乘
            10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
        斐波那契数列
            1 1 2 3 5 8 13 21 34......
        兔子繁殖问题
            这是一个有趣的古典数学问题，著名意大利数学家Fibonacci曾提出一个问题：有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？

## 函数的封装思想：模块化编程体会
将功能封装的尽可能单一，便于在程序不同位置进行调用。

    人类从古至今，习惯将事情分工，将一些内容做成一些公共模块，模块可以重复反复使用。
    模块化编程：将一些基础的公共的部分单独封装到一个函数内，可以多次被调用。

    案例：输出1000以内的质数，模块化编程。
    逆向思维的过程：输出1000以内的质数  →  判断是不是质数   →  找约数个数

    案例2：找1000以内的完美数：（一个数的约数除了它本身外其他约数和还等于这个数）。
    注意：模块化编程，可以让我们的程序更加优化，各个小模块要尽量功能单一，提高重复使用率

    Test1：
    盈数是一种特殊的自然数，除去它本身以外的所有约数和大于它本身。与完美数类似。
    使用函数方法编写一段程序。
    输出1~100的所有盈数。

    Test2：
    如果整数A 的全部约数（包括1，不包括A 本身）之和等于B，且整数B 的全部约数
    （包括1，不包括B 本身）之和等于A，则称整数A和B是一对亲密数。
    求2000 以内的全部亲密数。

## 闭包函数
    闭包：一个函数可以访问另外一个函数内部的变量；
    提取信息;
        两个函数
        局部变量
    链式作用域：
        经过探究发现，嵌套函数中，内层函数可以访问外层函数定义的局部变量；那么，正常的情况下，我们是需要在函数的外部的函数中获取这个函数内部的变量的，那么可不可以把内部嵌套的函数作为一个连通内外的桥梁，可以使我们在函数的外部调用函数内部的局部变量。
    闭包
        inner函数把它自己内部的语句，和自己声明时所处的作用域一起封装成了一个密闭环境，我们称为“闭包”。
        函数本身就是一个闭包。函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参考定义时的密闭环境。
        闭包天生存在，并不需要什么特殊的结构才存在，只不过我们必须要刻意地把函数放到其他的作用域中调用，才能明显的观察到闭包性质。
    js中任何一个函数都可以看做是闭包函数；（把整个脚本看做是一个外部函数）
    当两个以上对象之间产生关联，都不会被GC（垃圾回收器）回收
    如果闭包使用过多，会增加内存的消耗，使用不当可能会有内存泄露的风险，需要释放内存
    使用闭包可以避免全局变量污染

    ```
    <script>
        function f(){
            var i = 1;
            return function(){
                return i++;
            }
        }
        console.log(f());// ƒ (){return i++;}
        console.log(f()());// 1
        console.log(f()());// 1  每一次的调用都会形成一个新的闭包

        // 闭包：一个函数(这里探讨外部函数)访问另外一个函数内部的变量
        // inner函数把它自己内部的语句，和自己声明时所处的作用域一起封装成了一个密闭环境，我们称为“闭包”。
        // 函数本身就是一个闭包。函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参考定义时的密闭环境。
        // 闭包天生存在，并不需要什么特殊的结构才存在，只不过我们必须要刻意地把函数放到其他的作用域中调用，才能明显的观察到闭包性质。

        // fn();//Error: i is not defined
        // function fn(){
        //     console.log("i:",i);
        // }

        // 经过探究发现，嵌套函数中，内层函数可以访问外层函数定义的局部变量；那么，正常的情况下，我们是需要在函数的外部的函数中获取这个函数内部的变量的，
        // 那么可不可以把内部嵌套的函数作为一个连通内外的桥梁，可以使我们在函数的外部调用函数内部的局部变量。

        //全局位置声明一个变量，来接收f函数执行后返回的那个函数
        var test = f();

        console.log(test);// ƒ (){return i++;}
        console.log(test());//1
        console.log(test());//2

        //变量test是一个全局 变量，test和f内部匿名函数建立联系，内部的函数和f函数内部的局部变量建立联系
        //JS中垃圾回收机制中，局部变量，在函数调用完毕后进行空闲回收；全局变量页面关闭后回收
        //如果两个以上对象之间产生关联，那么这关联的对象都不会被回收
        //所以，上面test函数中形成闭包，里面局部变量i会被当做全局变量（产生引用关系）常驻内存

        var test2 = f();
        console.log(test2);// ƒ (){return i++;}
        console.log(test2());//1
        console.log(test2());//2
        console.log(test2());//3

        // 如果闭包使用过多，会增加内存的消耗，使用不当可能会有内存泄露的风险
        // 释放内存
        test = null;
        console.log(test); // null
    </script>
    ```
