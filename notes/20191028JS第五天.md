## 函数
#### 函数的作用域
    局部作用域
        在传统的js中，可以把声明函数后，大括号中函数体区域看做是局部作用域；在局部作用域内声明的变量叫做局部变量；局部变量只能在当前函数内调用，函数外无法调用；局部变量在函数调用时生成，函数调用完毕后销毁。
    全局作用域
        函数外部整个js脚本区域都可以看做是全局作用域；在全局作用域内声明的变量，叫做全局变量；全局变量可以在整个js脚本任何位置都可以调用；全局变量，在程序执行时（页面打开时）生成，程序(页面)关闭后销毁。
    ```
    var i = 1;
    f();
    function f(){
        console.log("i:",i);    // i:undefined
        var i = 2;
        console.log("i:",i);    // i: 2
        // 链式作用域改变：嵌套函数中，或不同作用域下，局部作用域中变量调用时，会先在当前作用域中寻找是否有这个变量的声明，如果没有再一层一层往上查找直到找到这个变量为止
    }
    console.log("i:",i);    // i: 1
    ```
#### 函数的重载和重写
    重载：在同一个程序中，声明多个函数名相同，参数列表的数量或数据类型不同的函数叫做函数的重载；
    重写：存在继承关系的程序中，子类去重新定义父类中的方法（函数），叫做重写；

    JS是一个动态的、弱类型语言。
    JS中不存在重载的概念，但是我们可以使用arguments对象模拟；
    如果在JS中声明了多个同名函数，后面的函数覆盖前面的函数。
#### arguments对象
    arguments 是一个对应于传递给函数的参数的类数组对象。
    JS中一个特殊的对象，代表的是所有的参数；它是一个参数列表，是一个类数组；
    类数组和数组一样，有长度，有索引；
    长度通过length属性获取，得到的是参数的个数；
    索引，也叫下标，都是从0开始，一次递增的
    可以通过索引获取对应索引的参数 arguments[0] 获取第一个参数  arguments[argument.length - 1]获取最后一个参数

#### 函数的返回值
    更多的时候，我们不会在函数中直接输出数据；会使用return关键字返回一个值，便于二次使用；
    return除了在函数调用时，可以返回指定的值；还可以用来跳出函数用。

    面试题：return 、break 、 continue区别
        return 调用函数时用来返回值或跳出函数用
        break用来跳出指定循环或者switch语句
        continue跳过本次循环继续下一次循环

## 匿名函数和立即执行函数（自执行函数）
    匿名函数：顾名思义，就是没有名字的函数
    立即执行函数（IIFE）:又称自执行函数，一般在程序运行时只执行一遍的操作，一般会使用自执行函数操作

    自执行函数由两个小括号包裹，第一个小括号包裹的是函数体，第二个小括号用来执行函数（第一个小括号也可以用别的符号代替，如~ ! + -）
    自执行函数前面的代码必须以分号结束，为了避免前面代码没用分号结束的情况，一般会在自执行函数前加个分号
    ```
    ;(function(a,b){
        console.log(a+b);
    })(10,20);
    ;~function(a,b){
        console.log(a+b);
    }(10,20);
    ```
    自执行函数可以避免全局变量的污染

## 递归函数
    一个函数在函数体内调用函数自己，叫做递归函数；
    递归函数一般用来解决数学问题。解决的都是大于0的数据操作；
    递归函数必须给定一个条件来跳出，否则会造成内存堆栈溢出( Maximum call stack size exceeded)。

    可以解决问题如：
        累加
            1 + 2 + 3 + ... + 97 + 98 + 99 + 100
        阶乘
            10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
        斐波那契数列
            1 1 2 3 5 8 13 21 34......
        兔子繁殖问题
            这是一个有趣的古典数学问题，著名意大利数学家Fibonacci曾提出一个问题：有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？

## 函数的封装思想：模块化编程体会
将功能封装的尽可能单一，便于在程序不同位置进行调用。

    人类从古至今，习惯将事情分工，将一些内容做成一些公共模块，模块可以重复反复使用。
    模块化编程：将一些基础的公共的部分单独封装到一个函数内，可以多次被调用。

    案例：输出1000以内的质数，模块化编程。
    逆向思维的过程：输出1000以内的质数  →  判断是不是质数   →  找约数个数

    案例2：找1000以内的完美数：（一个数的约数除了它本身外其他约数和还等于这个数）。
    注意：模块化编程，可以让我们的程序更加优化，各个小模块要尽量功能单一，提高重复使用率

    Test1：
    盈数是一种特殊的自然数，除去它本身以外的所有约数和大于它本身。与完美数类似。
    使用函数方法编写一段程序。
    输出1~100的所有盈数。

    Test2：
    如果整数A 的全部约数（包括1，不包括A 本身）之和等于B，且整数B 的全部约数
    （包括1，不包括B 本身）之和等于A，则称整数A和B是一对亲密数。
    求2000 以内的全部亲密数。

## 闭包函数
    闭包：一个函数可以访问另外一个函数内部的变量；
    提取信息;
        两个函数
        局部变量
    链式作用域：
        经过探究发现，嵌套函数中，内层函数可以访问外层函数定义的局部变量；那么，正常的情况下，我们是需要在函数的外部的函数中获取这个函数内部的变量的，那么可不可以把内部嵌套的函数作为一个连通内外的桥梁，可以使我们在函数的外部调用函数内部的局部变量。
    闭包
        inner函数把它自己内部的语句，和自己声明时所处的作用域一起封装成了一个密闭环境，我们称为“闭包”。
        函数本身就是一个闭包。函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参考定义时的密闭环境。
        闭包天生存在，并不需要什么特殊的结构才存在，只不过我们必须要刻意地把函数放到其他的作用域中调用，才能明显的观察到闭包性质。
    js中任何一个函数都可以看做是闭包函数；（把整个脚本看做是一个外部函数）
    当两个以上对象之间产生关联，都不会被GC（垃圾回收器）回收
    如果闭包使用过多，会增加内存的消耗，使用不当可能会有内存泄露的风险，需要释放内存
    使用闭包可以避免全局变量污染

    ```
    <script>
        function f(){
            var i = 1;
            return function(){
                return i++;
            }
        }
        console.log(f());// ƒ (){return i++;}
        console.log(f()());// 1
        console.log(f()());// 1  每一次的调用都会形成一个新的闭包

        // 闭包：一个函数(这里探讨外部函数)访问另外一个函数内部的变量
        // inner函数把它自己内部的语句，和自己声明时所处的作用域一起封装成了一个密闭环境，我们称为“闭包”。
        // 函数本身就是一个闭包。函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参考定义时的密闭环境。
        // 闭包天生存在，并不需要什么特殊的结构才存在，只不过我们必须要刻意地把函数放到其他的作用域中调用，才能明显的观察到闭包性质。

        // fn();//Error: i is not defined
        // function fn(){
        //     console.log("i:",i);
        // }

        // 经过探究发现，嵌套函数中，内层函数可以访问外层函数定义的局部变量；那么，正常的情况下，我们是需要在函数的外部的函数中获取这个函数内部的变量的，
        // 那么可不可以把内部嵌套的函数作为一个连通内外的桥梁，可以使我们在函数的外部调用函数内部的局部变量。

        //全局位置声明一个变量，来接收f函数执行后返回的那个函数
        var test = f();

        console.log(test);// ƒ (){return i++;}
        console.log(test());//1
        console.log(test());//2

        //变量test是一个全局 变量，test和f内部匿名函数建立联系，内部的函数和f函数内部的局部变量建立联系
        //JS中垃圾回收机制中，局部变量，在函数调用完毕后进行空闲回收；全局变量页面关闭后回收
        //如果两个以上对象之间产生关联，那么这关联的对象都不会被回收
        //所以，上面test函数中形成闭包，里面局部变量i会被当做全局变量（产生引用关系）常驻内存

        var test2 = f();
        console.log(test2);// ƒ (){return i++;}
        console.log(test2());//1
        console.log(test2());//2
        console.log(test2());//3

        // 如果闭包使用过多，会增加内存的消耗，使用不当可能会有内存泄露的风险
        // 释放内存
        test = null;
        console.log(test); // null
    </script>
    ```
